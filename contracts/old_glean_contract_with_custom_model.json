{
    "name": "glean",
    "description": "You are a helpful assistant for an employee of Glean Work (Name: Nikhil Mandava) (Email: nikhil.mandava@glean.com) (Country: United States) who works in Engineering.\n\n# GENERAL INSTRUCTIONS\n- Carefully analyze the user's query and construct a well-formatted input string for the tool based on the provided input specifications.\n- Do NOT expand any acronym used in the user's query to open forms. Use the original closed form in the search query.\n- Do not attempt to directly answer the user's question.\n- Do not provide anyother output besides the search query.\n\n# TOOL DESCRIPTION\nYou have access to Glean Search, which finds relevant documents in the company.\nINSTRUCTIONS:\n- This is your primary tool to access all knowledge within the company.\n- The results returned are not exhaustive, we only return the top few most relevant documents to a query.\n- For analytics questions such as \"how many documents...\" use the \"statistics\" field in the output.\n# TOOL INPUT SPECIFICATIONS\n- Search query should contain important keywords that help find relevant documents.\n- You can optionally narrow down the search results by using one or more of the following filter types:\n1. owner: filter to documents created by this person. Value can be a person's name (double quoted), or 'me'\n2. from: filter to documents updated by or commented on or created by this person. Value can be a person's name (double quoted), or 'me'\n3. updated: filter to documents updated on or after this date, value can be one of [\"today\", \"yesterday\", \"past_week\", \"past_2_weeks\", \"past_month\", \"March\", ...]\n4. after: filter to documents created after this date. Do not use a date later than today. value must be in \"YYYY-MM-DD\" format\n5. before: filter to documents created before this date. value must be in \"YYYY-MM-DD\" format\n6. documentCategory: filter to documents of a specific category. value based on the user's message might be \"tickets\"\n7. app: filter to documents created in a specific app. value based on the user's message might be \"jira\". Value must be double quoted. Only use the app filter when the user wants contents from an app.\n- Use date filters like \"updated\", \"after\", and \"before\" ONLY when the user has mentioned a specific time frame (e.g. last week, past month, before 12 Jan). Do NOT use date filters if the user requests the \"latest\" or \"recent\" documents or information but hasn't provided a specific time frame.- Do NOT use any other filter besides those explicitly listed above.\n# TOOL OUTPUT SPECIFICATIONS\n- The output from Glean Search is a JSON struct with 2 fields:\n1. \"documents\": a list of documents with Document struct. Each Document struct contains these fields: title, snippets, owner, updateTime, url.\n2. \"statistics\": counts of documents that match your query, broken down by different dimensions such as datasource, author, reviewer.\n\n\n# DEMONSTRATING EXAMPLES\n\nMessage: What did EmployeeA work on last week?\nOutput: [from:\"EmployeeA\" updated:past_week]\n\nMessage: what Slack channels have I been active this week?\nOutput: [from:me app:\"microsoftteams\" app:\"slack\" updated:past_week]\n\nMessage: what are some interesting calls to listen to on gong from last week\nOutput: [interesting updated:past_week app:\"gong\"]\n\nMessage: What Slack channels have I been active in this week\nOutput: [app:\"microsoftteams\" app:\"slack\" from:me updated:past_week]\n\nMessage: What was John Doe working on over the past month?\nOutput: [from:\"John Doe\" updated:past_month]\n\nMessage: What are the all the recent tickets about ProjectX?\nOutput: [ProjectX documentCategory:tickets updated:past_week]\n\nMessage: what has John Doe worked on in the past few days?\nOutput: [from:\"John Doe\" updated:past_week]\n\nMessage: what notion pages I've edited this week\nOutput: [from:me updated:past_week]\n\nMessage: what documents I've edited this week\nOutput: [from:me updated:past_week]\n\nMessage: Analyze and compare how our thinking about ProjectX has changed since last year till now\nOutput: [ProjectX after:2023-10-26, ProjectX after:2022-10-26 before:2023-10-26]\n\nMessage: Compare Foo and Bar\nOutput: [Foo, Bar, Foo vs Bar]\n\nMessage: Read through our ProductX features. Give me a list of potential enhancements we can make to the feature. You can get inspiration from our ChannelY slack channel. If you get an idea from slack, cite it as not your own\nOutput: [ProductX feature enhancements, channel:ChannelY app:\"slack\"]\n\nMessage: What happened with ProjectX in the last month?\nOutput: [ProjectX updated:past_month]\n\nMessage: What is the latest with ProjectX?\nOutput: [ProjectX]\n\nMessage: Write an executive email as to why ProductA is better suited for CompanyB than using ProductB. Use any context from meetings in the past month\nOutput: [ProductA vs ProductB, CompanyB meeting updated:past_month]",
    "dimensions": [
        {
            "label": "Unstructured Queries",
            "description": "Are unstructured queries handled appropriately?",
            "weight": 1.0,
            "sub_dimensions": [
                {
                    "label": "Direct Score Calculation",
                    "description": "Is the response good when the score is directly calculatable?",
                    "scoring_type": "CUSTOM_MODEL_SCORER",
                    "python_code": null,
                    "custom_model_id": "glean-dimension-scoring",
                    "parameters": null,
                    "weight": 1.0,
                    "action_dimension": null
                }
            ],
            "action_dimension": {
                "label": "Direct Score Calculation Eligibility",
                "description": "Is the score directly calculatable?",
                "scoring_type": "CUSTOM_MODEL_SCORER",
                "python_code": null,
                "custom_model_id": "glean-dimension-scoring",
                "action_on_low_score": false
            }
        },
        {
            "label": "PYTHON CHECKS",
            "description": "Does the output pass the programmatic sanity checking?",
            "weight": 1.0,
            "sub_dimensions": [
                {
                    "label": "Filter Database Compliance",
                    "description": "Are the filters in the output compliant with our database?",
                    "scoring_type": "PYTHON_CODE",
                    "python_code": "from typing import Any, Dict\nimport re\nfrom importlib.resources import files\n\n\nclass GleanScorer:\n    def _parse_query(self, query) -> tuple[dict[str, str], str]:\n        \"\"\"\n        Parse a query string into a dictionary of key-value pairs.\n\n        Args:\n            query (str): Query string to parse\n\n        Returns:\n            Dict[str, str]: Dictionary of parsed key-value pairs\n            str: Error msg which is basically duplicate filters\n        \"\"\"\n        # Pattern matches:\n        # 1. key:\"value with spaces\"    (double quoted values)\n        # 2. key:'value with spaces'    (single quoted values)\n        # 3. key:value                  (unquoted values without spaces)\n        # 4. key:                       (empty values)\n        pattern = r'(\\w+):(?:\"([^\"]+)\"|\\'([^\\']+)\\'|([^\\s]*))'\n\n        matches = re.finditer(pattern, query)\n        parsed = {}\n        error_msg = \"\"\n\n        for match in matches:\n            key = match.group(1)  # The operator/key\n            # Check each possible group (quoted double, quoted single, unquoted)\n            value = match.group(2) or match.group(3) or match.group(4) or \"\"\n            if key.lower() in parsed and value == parsed[key.lower()]:\n                error_msg = \"Duplicates for the filter: \" + key.lower()\n\n            parsed[key.lower()] = value\n\n        return parsed, error_msg\n\n    def __init__(self, **kwargs):\n        # Same function is used for all the glean dimension / nodes. The label tells us which node this current function invocation should act as.\n        # If the label is empty, the same run is going to check all the conditions for all the glean python dimensions / nodes.\n        self.label = kwargs.get(\"label\", \"\")\n        self.all_filters = {\n            \"app\",\n            \"documentcategory\",\n            \"type\",\n            \"updated\",\n            \"after\",\n            \"before\",\n            \"created\",\n            \"createdafter\",\n            \"createdbefore\",\n            \"from\",\n            \"author\",\n            \"owner\",\n            \"reporter\",\n            \"assignee\",\n            \"label\",\n            \"component\",\n            \"status\",\n            \"statuscategory\",\n            \"channel\",\n        }\n        self.app_filters = {\n            \"github\": {\n                \"after\",\n                \"app\",\n                \"assignee\",\n                \"author\",\n                \"before\",\n                \"businessunit\",\n                \"city\",\n                \"collection\",\n                \"commenter\",\n                \"country\",\n                \"created\",\n                \"createdafter\",\n                \"createdbefore\",\n                \"department\",\n                \"documentcategory\",\n                \"from\",\n                \"has\",\n                \"in\",\n                \"industry\",\n                \"label\",\n                \"location\",\n                \"mentions\",\n                \"my\",\n                \"organization\",\n                \"owner\",\n                \"region\",\n                \"reportsto\",\n                \"repository\",\n                \"reviewer\",\n                \"roletype\",\n                \"sortby\",\n                \"startafter\",\n                \"startbefore\",\n                \"state\",\n                \"status\",\n                \"title\",\n                \"type\",\n                \"updated\",\n                \"with\",\n            },\n            \"jira\": {\n                \"after\",\n                \"app\",\n                \"assignee\",\n                \"before\",\n                \"businessunit\",\n                \"category\",\n                \"changerisk\",\n                \"city\",\n                \"collection\",\n                \"commenter\",\n                \"component\",\n                \"connectorrequesttype\",\n                \"country\",\n                \"created\",\n                \"createdafter\",\n                \"createdbefore\",\n                \"creator\",\n                \"department\",\n                \"documentcategory\",\n                \"epicstatus\",\n                \"featuresize\",\n                \"feedbackfrom\",\n                \"from\",\n                \"has\",\n                \"in\",\n                \"industry\",\n                \"issuetype\",\n                \"label\",\n                \"launchtierformarketingsetbyproducttorequestmarketingsupportmarketingtoverify\",\n                \"launchvisibilitysetbyproducteng\",\n                \"location\",\n                \"mentions\",\n                \"my\",\n                \"owner\",\n                \"priority\",\n                \"product\",\n                \"productmarketingmanagerpmm\",\n                \"project\",\n                \"quarter\",\n                \"region\",\n                \"reporter\",\n                \"reportsto\",\n                \"resolution\",\n                \"resolutionets\",\n                \"roadmap\",\n                \"roletype\",\n                \"rootcauseets\",\n                \"sortby\",\n                \"sprint\",\n                \"startafter\",\n                \"startbefore\",\n                \"state\",\n                \"status\",\n                \"statuscategory\",\n                \"tag\",\n                \"team\",\n                \"title\",\n                \"type\",\n                \"updated\",\n                \"urgency\",\n                \"with\",\n                \"workstream\",\n            },\n            \"slack\": {\n                \"after\",\n                \"app\",\n                \"appinstance\",\n                \"author\",\n                \"before\",\n                \"businessunit\",\n                \"channel\",\n                \"city\",\n                \"collection\",\n                \"country\",\n                \"created\",\n                \"createdafter\",\n                \"createdbefore\",\n                \"department\",\n                \"documentcategory\",\n                \"from\",\n                \"has\",\n                \"in\",\n                \"industry\",\n                \"location\",\n                \"mentions\",\n                \"my\",\n                \"owner\",\n                \"region\",\n                \"reportsto\",\n                \"roletype\",\n                \"sortby\",\n                \"startafter\",\n                \"startbefore\",\n                \"state\",\n                \"status\",\n                \"title\",\n                \"type\",\n                \"updated\",\n                \"visibility\",\n                \"with\",\n                \"workspace\",\n            },\n            \"gong\": {\n                \"account\",\n                \"after\",\n                \"app\",\n                \"author\",\n                \"before\",\n                \"businessunit\",\n                \"city\",\n                \"collection\",\n                \"country\",\n                \"created\",\n                \"createdafter\",\n                \"createdbefore\",\n                \"department\",\n                \"documentcategory\",\n                \"from\",\n                \"has\",\n                \"industry\",\n                \"location\",\n                \"my\",\n                \"owner\",\n                \"participants\",\n                \"region\",\n                \"reportsto\",\n                \"roletype\",\n                \"sortby\",\n                \"startafter\",\n                \"startbefore\",\n                \"state\",\n                \"title\",\n                \"type\",\n                \"updated\",\n                \"with\",\n            },\n            \"drive\": {\n                \"after\",\n                \"app\",\n                \"appinstance\",\n                \"author\",\n                \"before\",\n                \"businessunit\",\n                \"city\",\n                \"collection\",\n                \"country\",\n                \"created\",\n                \"createdafter\",\n                \"createdbefore\",\n                \"department\",\n                \"documentcategory\",\n                \"editor\",\n                \"folder\",\n                \"from\",\n                \"has\",\n                \"in\",\n                \"industry\",\n                \"location\",\n                \"mentions\",\n                \"my\",\n                \"owner\",\n                \"region\",\n                \"reportsto\",\n                \"roletype\",\n                \"sortby\",\n                \"startafter\",\n                \"startbefore\",\n                \"state\",\n                \"title\",\n                \"type\",\n                \"updated\",\n                \"with\",\n            },\n            \"confluence\": {\n                \"after\",\n                \"app\",\n                \"appinstance\",\n                \"author\",\n                \"before\",\n                \"businessunit\",\n                \"city\",\n                \"collection\",\n                \"commenter\",\n                \"country\",\n                \"created\",\n                \"createdafter\",\n                \"createdbefore\",\n                \"department\",\n                \"documentcategory\",\n                \"editor\",\n                \"from\",\n                \"has\",\n                \"in\",\n                \"industry\",\n                \"label\",\n                \"location\",\n                \"mentions\",\n                \"my\",\n                \"owner\",\n                \"region\",\n                \"reportsto\",\n                \"roletype\",\n                \"sortby\",\n                \"space\",\n                \"startafter\",\n                \"startbefore\",\n                \"state\",\n                \"status\",\n                \"tag\",\n                \"title\",\n                \"type\",\n                \"updated\",\n                \"with\",\n            },\n            \"answers\": {\n                \"after\",\n                \"app\",\n                \"author\",\n                \"before\",\n                \"board\",\n                \"businessunit\",\n                \"city\",\n                \"collection\",\n                \"country\",\n                \"created\",\n                \"createdafter\",\n                \"createdbefore\",\n                \"creator\",\n                \"department\",\n                \"documentcategory\",\n                \"from\",\n                \"has\",\n                \"in\",\n                \"industry\",\n                \"label\",\n                \"location\",\n                \"mentions\",\n                \"my\",\n                \"owner\",\n                \"region\",\n                \"reportsto\",\n                \"roletype\",\n                \"sortby\",\n                \"startafter\",\n                \"startbefore\",\n                \"state\",\n                \"tag\",\n                \"title\",\n                \"type\",\n                \"updated\",\n                \"with\",\n            },\n        }\n\n    def is_valid_time_reference(self, s: str) -> bool:\n        if not s:\n            return False\n\n        s = s.strip()\n\n        patterns = [\n            # Relative time patterns\n            r\"^past_\\d+_(hours|days|weeks|months|years)$\",\n            r\"^past_(day|week|month|year|quarter|hour|weekend)$\",\n            r\"^past_few_(days|months)$\",\n            r\"^(this|next|last)_week$\",\n            r\"^(today|yesterday|tomorrow|recent)$\",\n            r\"^THIS_FISCAL_QUARTER$\",\n            r\"^annual$\",\n            # Days of the week\n            r\"^(Monday|Mon|Tuesday|Tues?|Wednesday|Wed|Thursday|Thurs?|Friday|Fri|Saturday|Sat|Sunday|Sun)$\",\n            # Calendar dates\n            r\"^\\d{4}-\\d{2}-\\d{2}$\",  # YYYY-MM-DD\n            r\"^\\d{4}-\\d{2}$\",  # YYYY-MM\n            r\"^\\d{4}$\",  # YYYY\n            # Months (including abbreviations)\n            r\"^(January|Jan|February|Feb|March|Mar|April|Apr|May|June|Jun|July|Jul|August|Aug|September|Sept?|October|Oct|November|Nov|December|Dec)$\",\n            r\"^(January|Jan|February|Feb|March|Mar|April|Apr|May|June|Jun|July|Jul|August|Aug|September|Sept?|October|Oct|November|Nov|December|Dec)-\\d{4}$\",\n            # Range operators\n            r\"^(before|after):\\d{4}-\\d{2}-\\d{2}$\",\n            r\"^\\d{4}-\\d{2}-\\d{2}\\.\\.\\d{4}-\\d{2}-\\d{2}$\",\n        ]\n\n        return any(re.match(pattern, s, re.IGNORECASE) for pattern in patterns)\n\n    def is_valid_app_name(self, s: str) -> bool:\n        patterns = [\n            # Common apps with exact names\n            r\"^(customer|slack|jira|github|email|glean|gong|gmail|loom|asana|gitlab|githubenterprise|confluence|zendesk|figma|metabase|linkedin|okta|notion|bazel|azure|miro|sigma|twitter)$\",\n            # Apps that might have variations\n            r\"^(google\\s*(drive|calendar|slides)|microsoft\\s*teams|ms\\s*teams|sharepoint|g(cal|drive|chat))$\",\n            # Services with common prefixes\n            r\"^(sales|service)cloud$\",\n            r\"^(app\\s*builder|glean\\s*(support|website|assistant)|sales\\s*cloud|service\\s*cloud)$\",\n        ]\n\n        # Convert to lowercase for matching\n        s = s.lower().strip()\n\n        # Ignore malformed entries with quotes or brackets\n        if any(char in s for char in '\"[]\\\\'):\n            return False\n\n        return any(re.match(pattern, s, re.IGNORECASE) for pattern in patterns)\n\n    def is_valid_type(self, s: str) -> bool:\n        patterns = [\n            # Common document types\n            r\"^(document|spreadsheet|presentation|pdf|file|doc|slides|form|image|video)$\",\n            # Code/development related\n            r\"^(pull|pr|commit|repo|code|component|issue|bug)$\",\n            # Project management\n            r\"^(project|task|epic|story|ticket|release|case)$\",\n            # Communication types\n            r\"^(meeting|call|message|thread|conversation|direct_message|announcement)$\",\n            # Business/CRM related\n            r\"^(opportunity|account|contact)$\",\n            # Storage/organization\n            r\"^(folder|dir|collection|table)$\",\n            # Knowledge/content\n            r\"^(article|blog|answer|description)$\",\n        ]\n\n        # Convert to lowercase for matching\n        s = s.lower().strip()\n\n        # Ignore malformed entries with quotes or brackets\n        if any(char in s for char in '\"[]\\\\'):\n            return False\n\n        return any(re.match(pattern, s, re.IGNORECASE) for pattern in patterns)\n\n    def is_valid_status(self, s: str) -> bool:\n        patterns = [\n            # Common status states\n            r\"^(open|closed|merged|draft|pending|solved|assigned|submitted)$\",\n            # Business outcomes\n            r\"^(won|closed[\\s-]won)$\",\n            # Project stages\n            r\"^(beta|backlog|in\\s*roadmap|scheduled\\/in\\s*roadmap|to\\s*do|qa\\s*fr\\s*complete)$\",\n            # Special states\n            r\"^(hold|unread|outstanding|parking)$\",\n        ]\n\n        # Convert to lowercase and clean\n        s = s.lower().strip()\n\n        # Ignore entries with quotes or brackets\n        if any(char in s for char in '\"[]\\\\'):\n            return False\n\n        return any(re.match(pattern, s, re.IGNORECASE) for pattern in patterns)\n\n    def is_valid_status_category(self, s: str) -> bool:\n        patterns = [\n            # Common status categories\n            r\"^(in_progress|to_do|todo|done|blocked|backlog|in_review)$\",\n        ]\n\n        # Convert to lowercase and normalize\n        s = s.lower().strip().replace(\" \", \"_\")\n\n        return any(re.match(pattern, s, re.IGNORECASE) for pattern in patterns)\n\n    def is_valid_document_category(self, s: str) -> bool:\n        patterns = [\n            # Common status categories\n            r\"^(tickets|messaging|code_repository)$\",\n        ]\n\n        # Convert to lowercase and normalize\n        s = s.lower().strip().replace(\" \", \"_\")\n\n        return any(re.match(pattern, s, re.IGNORECASE) for pattern in patterns)\n\n    def is_valid_name(self, s: str) -> bool:\n        patterns = [\n            # General email pattern (username@domain.com)\n            r\"^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$\",\n            # Email pattern which accepts: mailto:\n            r\"^(?:mailto:)?[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$\",\n            # Full names (First Last or First)\n            r\"^[A-Z][a-z]+(\\s+[A-Z][a-z]+)*$\",  # Capitalized words\n            r\"^[a-z]+$\",  # Single lowercase name\n            # Dot-separated names (First.Last)\n            r\"^[A-Z][a-z]+\\.[A-Z][a-z]+$\",  # Like Hannah.Abouchar\n            # Special assignees\n            r\"^(me)$\",\n            # Team names\n            r\"^[a-z\\s]+ team$\",  # like \"front end team\"\n        ]\n\n        # Clean the input\n        s = s.strip()\n        return any(re.match(pattern, s, re.IGNORECASE) for pattern in patterns)\n\n    def is_valid_input_for_channel(self, s: str) -> bool:\n        patterns = [\n            r\"#\\S+\",  # Match # followed by any non-whitespace characters, anywhere in string\n            r\"channel\",  # Match 'channel' anywhere in string\n        ]\n\n        # Convert to lowercase and normalize\n        s = s.lower().strip()\n\n        return any(re.search(pattern, s, re.IGNORECASE) for pattern in patterns)\n\n    def is_valid_input_for_label(self, s: str) -> bool:\n        patterns = [\n            r\"label\"  # Match 'label' anywhere in string\n        ]\n\n        # Convert to lowercase and normalize\n        s = s.lower().strip()\n\n        return any(re.search(pattern, s, re.IGNORECASE) for pattern in patterns)\n\n    def filter_database_check(self, input_text, output_text):\n        for key, val in self._parse_query(output_text)[0].items():\n            if key == \"app\":\n                if not self.is_valid_app_name(val):\n                    return 0.0, \"bad app value: \" + val\n\n            if key == \"documentcategory\":\n                if not self.is_valid_document_category(val):\n                    return 0.0, \"bad document category: \" + val\n\n            if key == \"type\":\n                if not self.is_valid_type(val):\n                    return 0.0, \"bad type: \" + val\n\n            if (\n                key == \"updated\"\n                or key == \"after\"\n                or key == \"before\"\n                or key == \"created\"\n                or key == \"createdafter\"\n                or key == \"createdbefore\"\n            ):\n                if not self.is_valid_time_reference(val):\n                    return 0.0, \"bad time reference format: \" + val\n\n            if (\n                key == \"from\"\n                or key == \"author\"\n                or key == \"owner\"\n                or key == \"reporter\"\n                or key == \"assignee\"\n            ):\n                if not self.is_valid_name(val):\n                    return 0.0, \"bad name or alias or entity: \" + val\n\n            if key == \"status\":\n                if not self.is_valid_status(val):\n                    return 0.0, \"bad status value: \" + val\n\n            if key == \"statuscategory\":\n                if not self.is_valid_status_category(val):\n                    return 0.0, \"bad status category: \" + val\n\n            if key == \"channel\":\n                if not self.is_valid_input_for_channel(input_text):\n                    return 0.0, \"no explicit ask for channel in the input\"\n\n            if key == \"label\":\n                if not self.is_valid_input_for_label(input_text):\n                    return 0.0, \"no explicit ask for label in the input\"\n\n        return 1.0, \"all good filters\"\n\n    def evaluate(\n        self,\n        input_text: str,\n        response_text: str,\n    ) -> dict:\n        score = 1.0\n        explanations = []\n        app_name = \"\"\n        label_score = {}\n\n        filter_and_value, error_msg = self._parse_query(response_text)\n        if error_msg != \"\":\n            score = 0.0\n            explanations.append(error_msg)\n            label_score[\"Output Format\"] = 0\n        if \"app\" in filter_and_value:\n            app_name = filter_and_value[\"app\"]\n\n        unknown_filters = []\n        for filter, value in filter_and_value.items():\n            if value == \"\":\n                score = 0.0\n                explanations.append(\"Empty filter value: \" + filter)\n                label_score[\"Output Format\"] = 0\n\n            if filter not in self.all_filters:\n                unknown_filters.append(filter)\n\n            if app_name != \"\" and filter != \"app\":\n                if app_name not in self.app_filters:\n                    # We don't have list of filters for this app.\n                    continue\n                if filter not in self.app_filters[app_name]:\n                    score = 0.0\n                    explanations.append(\n                        \"App: \" + app_name + \" cannot use the filter: \" + filter\n                    )\n                    label_score[\"App Compatibility\"] = 0\n\n        if len(unknown_filters) > 0:\n            score = 0.0\n            explanations.append(\"Unknown Filter: \" + \", \".join(unknown_filters))\n            label_score[\"Unknown Filters\"] = 0\n\n        d_score, d_expl = self.filter_database_check(input_text, response_text)\n        label_score[\"Filter Database Compliance\"] = d_score\n\n        if d_score < 1.0:\n            score = 0.0\n            explanations.append(d_expl)\n\n        # Only check the conditions corresponding to the dimension with self.label.\n        final_score = score if self.label == \"\" else label_score.get(self.label, 1.0)\n\n        return {\"score\": final_score, \"explanation\": \" | \".join(explanations)}\n\n\ndef score(\n    response_text: str,\n    input_text: str,\n    input_args: dict[str, Any],\n    kwargs: dict[str, Any],\n) -> dict:\n    scorer = GleanScorer(**kwargs)\n    return scorer.evaluate(input_text, response_text)\n",
                    "custom_model_id": null,
                    "parameters": null,
                    "weight": 1.0,
                    "action_dimension": null
                },
                {
                    "label": "Output Format",
                    "description": "Is the output search query in the correct format?",
                    "scoring_type": "PYTHON_CODE",
                    "python_code": "from typing import Any, Dict\nimport re\nfrom importlib.resources import files\n\n\nclass GleanScorer:\n    def _parse_query(self, query) -> tuple[dict[str, str], str]:\n        \"\"\"\n        Parse a query string into a dictionary of key-value pairs.\n\n        Args:\n            query (str): Query string to parse\n\n        Returns:\n            Dict[str, str]: Dictionary of parsed key-value pairs\n            str: Error msg which is basically duplicate filters\n        \"\"\"\n        # Pattern matches:\n        # 1. key:\"value with spaces\"    (double quoted values)\n        # 2. key:'value with spaces'    (single quoted values)\n        # 3. key:value                  (unquoted values without spaces)\n        # 4. key:                       (empty values)\n        pattern = r'(\\w+):(?:\"([^\"]+)\"|\\'([^\\']+)\\'|([^\\s]*))'\n\n        matches = re.finditer(pattern, query)\n        parsed = {}\n        error_msg = \"\"\n\n        for match in matches:\n            key = match.group(1)  # The operator/key\n            # Check each possible group (quoted double, quoted single, unquoted)\n            value = match.group(2) or match.group(3) or match.group(4) or \"\"\n            if key.lower() in parsed and value == parsed[key.lower()]:\n                error_msg = \"Duplicates for the filter: \" + key.lower()\n\n            parsed[key.lower()] = value\n\n        return parsed, error_msg\n\n    def __init__(self, **kwargs):\n        # Same function is used for all the glean dimension / nodes. The label tells us which node this current function invocation should act as.\n        # If the label is empty, the same run is going to check all the conditions for all the glean python dimensions / nodes.\n        self.label = kwargs.get(\"label\", \"\")\n        self.all_filters = {\n            \"app\",\n            \"documentcategory\",\n            \"type\",\n            \"updated\",\n            \"after\",\n            \"before\",\n            \"created\",\n            \"createdafter\",\n            \"createdbefore\",\n            \"from\",\n            \"author\",\n            \"owner\",\n            \"reporter\",\n            \"assignee\",\n            \"label\",\n            \"component\",\n            \"status\",\n            \"statuscategory\",\n            \"channel\",\n        }\n        self.app_filters = {\n            \"github\": {\n                \"after\",\n                \"app\",\n                \"assignee\",\n                \"author\",\n                \"before\",\n                \"businessunit\",\n                \"city\",\n                \"collection\",\n                \"commenter\",\n                \"country\",\n                \"created\",\n                \"createdafter\",\n                \"createdbefore\",\n                \"department\",\n                \"documentcategory\",\n                \"from\",\n                \"has\",\n                \"in\",\n                \"industry\",\n                \"label\",\n                \"location\",\n                \"mentions\",\n                \"my\",\n                \"organization\",\n                \"owner\",\n                \"region\",\n                \"reportsto\",\n                \"repository\",\n                \"reviewer\",\n                \"roletype\",\n                \"sortby\",\n                \"startafter\",\n                \"startbefore\",\n                \"state\",\n                \"status\",\n                \"title\",\n                \"type\",\n                \"updated\",\n                \"with\",\n            },\n            \"jira\": {\n                \"after\",\n                \"app\",\n                \"assignee\",\n                \"before\",\n                \"businessunit\",\n                \"category\",\n                \"changerisk\",\n                \"city\",\n                \"collection\",\n                \"commenter\",\n                \"component\",\n                \"connectorrequesttype\",\n                \"country\",\n                \"created\",\n                \"createdafter\",\n                \"createdbefore\",\n                \"creator\",\n                \"department\",\n                \"documentcategory\",\n                \"epicstatus\",\n                \"featuresize\",\n                \"feedbackfrom\",\n                \"from\",\n                \"has\",\n                \"in\",\n                \"industry\",\n                \"issuetype\",\n                \"label\",\n                \"launchtierformarketingsetbyproducttorequestmarketingsupportmarketingtoverify\",\n                \"launchvisibilitysetbyproducteng\",\n                \"location\",\n                \"mentions\",\n                \"my\",\n                \"owner\",\n                \"priority\",\n                \"product\",\n                \"productmarketingmanagerpmm\",\n                \"project\",\n                \"quarter\",\n                \"region\",\n                \"reporter\",\n                \"reportsto\",\n                \"resolution\",\n                \"resolutionets\",\n                \"roadmap\",\n                \"roletype\",\n                \"rootcauseets\",\n                \"sortby\",\n                \"sprint\",\n                \"startafter\",\n                \"startbefore\",\n                \"state\",\n                \"status\",\n                \"statuscategory\",\n                \"tag\",\n                \"team\",\n                \"title\",\n                \"type\",\n                \"updated\",\n                \"urgency\",\n                \"with\",\n                \"workstream\",\n            },\n            \"slack\": {\n                \"after\",\n                \"app\",\n                \"appinstance\",\n                \"author\",\n                \"before\",\n                \"businessunit\",\n                \"channel\",\n                \"city\",\n                \"collection\",\n                \"country\",\n                \"created\",\n                \"createdafter\",\n                \"createdbefore\",\n                \"department\",\n                \"documentcategory\",\n                \"from\",\n                \"has\",\n                \"in\",\n                \"industry\",\n                \"location\",\n                \"mentions\",\n                \"my\",\n                \"owner\",\n                \"region\",\n                \"reportsto\",\n                \"roletype\",\n                \"sortby\",\n                \"startafter\",\n                \"startbefore\",\n                \"state\",\n                \"status\",\n                \"title\",\n                \"type\",\n                \"updated\",\n                \"visibility\",\n                \"with\",\n                \"workspace\",\n            },\n            \"gong\": {\n                \"account\",\n                \"after\",\n                \"app\",\n                \"author\",\n                \"before\",\n                \"businessunit\",\n                \"city\",\n                \"collection\",\n                \"country\",\n                \"created\",\n                \"createdafter\",\n                \"createdbefore\",\n                \"department\",\n                \"documentcategory\",\n                \"from\",\n                \"has\",\n                \"industry\",\n                \"location\",\n                \"my\",\n                \"owner\",\n                \"participants\",\n                \"region\",\n                \"reportsto\",\n                \"roletype\",\n                \"sortby\",\n                \"startafter\",\n                \"startbefore\",\n                \"state\",\n                \"title\",\n                \"type\",\n                \"updated\",\n                \"with\",\n            },\n            \"drive\": {\n                \"after\",\n                \"app\",\n                \"appinstance\",\n                \"author\",\n                \"before\",\n                \"businessunit\",\n                \"city\",\n                \"collection\",\n                \"country\",\n                \"created\",\n                \"createdafter\",\n                \"createdbefore\",\n                \"department\",\n                \"documentcategory\",\n                \"editor\",\n                \"folder\",\n                \"from\",\n                \"has\",\n                \"in\",\n                \"industry\",\n                \"location\",\n                \"mentions\",\n                \"my\",\n                \"owner\",\n                \"region\",\n                \"reportsto\",\n                \"roletype\",\n                \"sortby\",\n                \"startafter\",\n                \"startbefore\",\n                \"state\",\n                \"title\",\n                \"type\",\n                \"updated\",\n                \"with\",\n            },\n            \"confluence\": {\n                \"after\",\n                \"app\",\n                \"appinstance\",\n                \"author\",\n                \"before\",\n                \"businessunit\",\n                \"city\",\n                \"collection\",\n                \"commenter\",\n                \"country\",\n                \"created\",\n                \"createdafter\",\n                \"createdbefore\",\n                \"department\",\n                \"documentcategory\",\n                \"editor\",\n                \"from\",\n                \"has\",\n                \"in\",\n                \"industry\",\n                \"label\",\n                \"location\",\n                \"mentions\",\n                \"my\",\n                \"owner\",\n                \"region\",\n                \"reportsto\",\n                \"roletype\",\n                \"sortby\",\n                \"space\",\n                \"startafter\",\n                \"startbefore\",\n                \"state\",\n                \"status\",\n                \"tag\",\n                \"title\",\n                \"type\",\n                \"updated\",\n                \"with\",\n            },\n            \"answers\": {\n                \"after\",\n                \"app\",\n                \"author\",\n                \"before\",\n                \"board\",\n                \"businessunit\",\n                \"city\",\n                \"collection\",\n                \"country\",\n                \"created\",\n                \"createdafter\",\n                \"createdbefore\",\n                \"creator\",\n                \"department\",\n                \"documentcategory\",\n                \"from\",\n                \"has\",\n                \"in\",\n                \"industry\",\n                \"label\",\n                \"location\",\n                \"mentions\",\n                \"my\",\n                \"owner\",\n                \"region\",\n                \"reportsto\",\n                \"roletype\",\n                \"sortby\",\n                \"startafter\",\n                \"startbefore\",\n                \"state\",\n                \"tag\",\n                \"title\",\n                \"type\",\n                \"updated\",\n                \"with\",\n            },\n        }\n\n    def is_valid_time_reference(self, s: str) -> bool:\n        if not s:\n            return False\n\n        s = s.strip()\n\n        patterns = [\n            # Relative time patterns\n            r\"^past_\\d+_(hours|days|weeks|months|years)$\",\n            r\"^past_(day|week|month|year|quarter|hour|weekend)$\",\n            r\"^past_few_(days|months)$\",\n            r\"^(this|next|last)_week$\",\n            r\"^(today|yesterday|tomorrow|recent)$\",\n            r\"^THIS_FISCAL_QUARTER$\",\n            r\"^annual$\",\n            # Days of the week\n            r\"^(Monday|Mon|Tuesday|Tues?|Wednesday|Wed|Thursday|Thurs?|Friday|Fri|Saturday|Sat|Sunday|Sun)$\",\n            # Calendar dates\n            r\"^\\d{4}-\\d{2}-\\d{2}$\",  # YYYY-MM-DD\n            r\"^\\d{4}-\\d{2}$\",  # YYYY-MM\n            r\"^\\d{4}$\",  # YYYY\n            # Months (including abbreviations)\n            r\"^(January|Jan|February|Feb|March|Mar|April|Apr|May|June|Jun|July|Jul|August|Aug|September|Sept?|October|Oct|November|Nov|December|Dec)$\",\n            r\"^(January|Jan|February|Feb|March|Mar|April|Apr|May|June|Jun|July|Jul|August|Aug|September|Sept?|October|Oct|November|Nov|December|Dec)-\\d{4}$\",\n            # Range operators\n            r\"^(before|after):\\d{4}-\\d{2}-\\d{2}$\",\n            r\"^\\d{4}-\\d{2}-\\d{2}\\.\\.\\d{4}-\\d{2}-\\d{2}$\",\n        ]\n\n        return any(re.match(pattern, s, re.IGNORECASE) for pattern in patterns)\n\n    def is_valid_app_name(self, s: str) -> bool:\n        patterns = [\n            # Common apps with exact names\n            r\"^(customer|slack|jira|github|email|glean|gong|gmail|loom|asana|gitlab|githubenterprise|confluence|zendesk|figma|metabase|linkedin|okta|notion|bazel|azure|miro|sigma|twitter)$\",\n            # Apps that might have variations\n            r\"^(google\\s*(drive|calendar|slides)|microsoft\\s*teams|ms\\s*teams|sharepoint|g(cal|drive|chat))$\",\n            # Services with common prefixes\n            r\"^(sales|service)cloud$\",\n            r\"^(app\\s*builder|glean\\s*(support|website|assistant)|sales\\s*cloud|service\\s*cloud)$\",\n        ]\n\n        # Convert to lowercase for matching\n        s = s.lower().strip()\n\n        # Ignore malformed entries with quotes or brackets\n        if any(char in s for char in '\"[]\\\\'):\n            return False\n\n        return any(re.match(pattern, s, re.IGNORECASE) for pattern in patterns)\n\n    def is_valid_type(self, s: str) -> bool:\n        patterns = [\n            # Common document types\n            r\"^(document|spreadsheet|presentation|pdf|file|doc|slides|form|image|video)$\",\n            # Code/development related\n            r\"^(pull|pr|commit|repo|code|component|issue|bug)$\",\n            # Project management\n            r\"^(project|task|epic|story|ticket|release|case)$\",\n            # Communication types\n            r\"^(meeting|call|message|thread|conversation|direct_message|announcement)$\",\n            # Business/CRM related\n            r\"^(opportunity|account|contact)$\",\n            # Storage/organization\n            r\"^(folder|dir|collection|table)$\",\n            # Knowledge/content\n            r\"^(article|blog|answer|description)$\",\n        ]\n\n        # Convert to lowercase for matching\n        s = s.lower().strip()\n\n        # Ignore malformed entries with quotes or brackets\n        if any(char in s for char in '\"[]\\\\'):\n            return False\n\n        return any(re.match(pattern, s, re.IGNORECASE) for pattern in patterns)\n\n    def is_valid_status(self, s: str) -> bool:\n        patterns = [\n            # Common status states\n            r\"^(open|closed|merged|draft|pending|solved|assigned|submitted)$\",\n            # Business outcomes\n            r\"^(won|closed[\\s-]won)$\",\n            # Project stages\n            r\"^(beta|backlog|in\\s*roadmap|scheduled\\/in\\s*roadmap|to\\s*do|qa\\s*fr\\s*complete)$\",\n            # Special states\n            r\"^(hold|unread|outstanding|parking)$\",\n        ]\n\n        # Convert to lowercase and clean\n        s = s.lower().strip()\n\n        # Ignore entries with quotes or brackets\n        if any(char in s for char in '\"[]\\\\'):\n            return False\n\n        return any(re.match(pattern, s, re.IGNORECASE) for pattern in patterns)\n\n    def is_valid_status_category(self, s: str) -> bool:\n        patterns = [\n            # Common status categories\n            r\"^(in_progress|to_do|todo|done|blocked|backlog|in_review)$\",\n        ]\n\n        # Convert to lowercase and normalize\n        s = s.lower().strip().replace(\" \", \"_\")\n\n        return any(re.match(pattern, s, re.IGNORECASE) for pattern in patterns)\n\n    def is_valid_document_category(self, s: str) -> bool:\n        patterns = [\n            # Common status categories\n            r\"^(tickets|messaging|code_repository)$\",\n        ]\n\n        # Convert to lowercase and normalize\n        s = s.lower().strip().replace(\" \", \"_\")\n\n        return any(re.match(pattern, s, re.IGNORECASE) for pattern in patterns)\n\n    def is_valid_name(self, s: str) -> bool:\n        patterns = [\n            # General email pattern (username@domain.com)\n            r\"^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$\",\n            # Email pattern which accepts: mailto:\n            r\"^(?:mailto:)?[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$\",\n            # Full names (First Last or First)\n            r\"^[A-Z][a-z]+(\\s+[A-Z][a-z]+)*$\",  # Capitalized words\n            r\"^[a-z]+$\",  # Single lowercase name\n            # Dot-separated names (First.Last)\n            r\"^[A-Z][a-z]+\\.[A-Z][a-z]+$\",  # Like Hannah.Abouchar\n            # Special assignees\n            r\"^(me)$\",\n            # Team names\n            r\"^[a-z\\s]+ team$\",  # like \"front end team\"\n        ]\n\n        # Clean the input\n        s = s.strip()\n        return any(re.match(pattern, s, re.IGNORECASE) for pattern in patterns)\n\n    def is_valid_input_for_channel(self, s: str) -> bool:\n        patterns = [\n            r\"#\\S+\",  # Match # followed by any non-whitespace characters, anywhere in string\n            r\"channel\",  # Match 'channel' anywhere in string\n        ]\n\n        # Convert to lowercase and normalize\n        s = s.lower().strip()\n\n        return any(re.search(pattern, s, re.IGNORECASE) for pattern in patterns)\n\n    def is_valid_input_for_label(self, s: str) -> bool:\n        patterns = [\n            r\"label\"  # Match 'label' anywhere in string\n        ]\n\n        # Convert to lowercase and normalize\n        s = s.lower().strip()\n\n        return any(re.search(pattern, s, re.IGNORECASE) for pattern in patterns)\n\n    def filter_database_check(self, input_text, output_text):\n        for key, val in self._parse_query(output_text)[0].items():\n            if key == \"app\":\n                if not self.is_valid_app_name(val):\n                    return 0.0, \"bad app value: \" + val\n\n            if key == \"documentcategory\":\n                if not self.is_valid_document_category(val):\n                    return 0.0, \"bad document category: \" + val\n\n            if key == \"type\":\n                if not self.is_valid_type(val):\n                    return 0.0, \"bad type: \" + val\n\n            if (\n                key == \"updated\"\n                or key == \"after\"\n                or key == \"before\"\n                or key == \"created\"\n                or key == \"createdafter\"\n                or key == \"createdbefore\"\n            ):\n                if not self.is_valid_time_reference(val):\n                    return 0.0, \"bad time reference format: \" + val\n\n            if (\n                key == \"from\"\n                or key == \"author\"\n                or key == \"owner\"\n                or key == \"reporter\"\n                or key == \"assignee\"\n            ):\n                if not self.is_valid_name(val):\n                    return 0.0, \"bad name or alias or entity: \" + val\n\n            if key == \"status\":\n                if not self.is_valid_status(val):\n                    return 0.0, \"bad status value: \" + val\n\n            if key == \"statuscategory\":\n                if not self.is_valid_status_category(val):\n                    return 0.0, \"bad status category: \" + val\n\n            if key == \"channel\":\n                if not self.is_valid_input_for_channel(input_text):\n                    return 0.0, \"no explicit ask for channel in the input\"\n\n            if key == \"label\":\n                if not self.is_valid_input_for_label(input_text):\n                    return 0.0, \"no explicit ask for label in the input\"\n\n        return 1.0, \"all good filters\"\n\n    def evaluate(\n        self,\n        input_text: str,\n        response_text: str,\n    ) -> dict:\n        score = 1.0\n        explanations = []\n        app_name = \"\"\n        label_score = {}\n\n        filter_and_value, error_msg = self._parse_query(response_text)\n        if error_msg != \"\":\n            score = 0.0\n            explanations.append(error_msg)\n            label_score[\"Output Format\"] = 0\n        if \"app\" in filter_and_value:\n            app_name = filter_and_value[\"app\"]\n\n        unknown_filters = []\n        for filter, value in filter_and_value.items():\n            if value == \"\":\n                score = 0.0\n                explanations.append(\"Empty filter value: \" + filter)\n                label_score[\"Output Format\"] = 0\n\n            if filter not in self.all_filters:\n                unknown_filters.append(filter)\n\n            if app_name != \"\" and filter != \"app\":\n                if app_name not in self.app_filters:\n                    # We don't have list of filters for this app.\n                    continue\n                if filter not in self.app_filters[app_name]:\n                    score = 0.0\n                    explanations.append(\n                        \"App: \" + app_name + \" cannot use the filter: \" + filter\n                    )\n                    label_score[\"App Compatibility\"] = 0\n\n        if len(unknown_filters) > 0:\n            score = 0.0\n            explanations.append(\"Unknown Filter: \" + \", \".join(unknown_filters))\n            label_score[\"Unknown Filters\"] = 0\n\n        d_score, d_expl = self.filter_database_check(input_text, response_text)\n        label_score[\"Filter Database Compliance\"] = d_score\n\n        if d_score < 1.0:\n            score = 0.0\n            explanations.append(d_expl)\n\n        # Only check the conditions corresponding to the dimension with self.label.\n        final_score = score if self.label == \"\" else label_score.get(self.label, 1.0)\n\n        return {\"score\": final_score, \"explanation\": \" | \".join(explanations)}\n\n\ndef score(\n    response_text: str,\n    input_text: str,\n    input_args: dict[str, Any],\n    kwargs: dict[str, Any],\n) -> dict:\n    scorer = GleanScorer(**kwargs)\n    return scorer.evaluate(input_text, response_text)\n",
                    "custom_model_id": null,
                    "parameters": null,
                    "weight": 1.0,
                    "action_dimension": null
                },
                {
                    "label": "App Compatability",
                    "description": "In case of multiple filters in the response where one of the filters is 'app', are other filters valid?",
                    "scoring_type": "PYTHON_CODE",
                    "python_code": "from typing import Any, Dict\nimport re\nfrom importlib.resources import files\n\n\nclass GleanScorer:\n    def _parse_query(self, query) -> tuple[dict[str, str], str]:\n        \"\"\"\n        Parse a query string into a dictionary of key-value pairs.\n\n        Args:\n            query (str): Query string to parse\n\n        Returns:\n            Dict[str, str]: Dictionary of parsed key-value pairs\n            str: Error msg which is basically duplicate filters\n        \"\"\"\n        # Pattern matches:\n        # 1. key:\"value with spaces\"    (double quoted values)\n        # 2. key:'value with spaces'    (single quoted values)\n        # 3. key:value                  (unquoted values without spaces)\n        # 4. key:                       (empty values)\n        pattern = r'(\\w+):(?:\"([^\"]+)\"|\\'([^\\']+)\\'|([^\\s]*))'\n\n        matches = re.finditer(pattern, query)\n        parsed = {}\n        error_msg = \"\"\n\n        for match in matches:\n            key = match.group(1)  # The operator/key\n            # Check each possible group (quoted double, quoted single, unquoted)\n            value = match.group(2) or match.group(3) or match.group(4) or \"\"\n            if key.lower() in parsed and value == parsed[key.lower()]:\n                error_msg = \"Duplicates for the filter: \" + key.lower()\n\n            parsed[key.lower()] = value\n\n        return parsed, error_msg\n\n    def __init__(self, **kwargs):\n        # Same function is used for all the glean dimension / nodes. The label tells us which node this current function invocation should act as.\n        # If the label is empty, the same run is going to check all the conditions for all the glean python dimensions / nodes.\n        self.label = kwargs.get(\"label\", \"\")\n        self.all_filters = {\n            \"app\",\n            \"documentcategory\",\n            \"type\",\n            \"updated\",\n            \"after\",\n            \"before\",\n            \"created\",\n            \"createdafter\",\n            \"createdbefore\",\n            \"from\",\n            \"author\",\n            \"owner\",\n            \"reporter\",\n            \"assignee\",\n            \"label\",\n            \"component\",\n            \"status\",\n            \"statuscategory\",\n            \"channel\",\n        }\n        self.app_filters = {\n            \"github\": {\n                \"after\",\n                \"app\",\n                \"assignee\",\n                \"author\",\n                \"before\",\n                \"businessunit\",\n                \"city\",\n                \"collection\",\n                \"commenter\",\n                \"country\",\n                \"created\",\n                \"createdafter\",\n                \"createdbefore\",\n                \"department\",\n                \"documentcategory\",\n                \"from\",\n                \"has\",\n                \"in\",\n                \"industry\",\n                \"label\",\n                \"location\",\n                \"mentions\",\n                \"my\",\n                \"organization\",\n                \"owner\",\n                \"region\",\n                \"reportsto\",\n                \"repository\",\n                \"reviewer\",\n                \"roletype\",\n                \"sortby\",\n                \"startafter\",\n                \"startbefore\",\n                \"state\",\n                \"status\",\n                \"title\",\n                \"type\",\n                \"updated\",\n                \"with\",\n            },\n            \"jira\": {\n                \"after\",\n                \"app\",\n                \"assignee\",\n                \"before\",\n                \"businessunit\",\n                \"category\",\n                \"changerisk\",\n                \"city\",\n                \"collection\",\n                \"commenter\",\n                \"component\",\n                \"connectorrequesttype\",\n                \"country\",\n                \"created\",\n                \"createdafter\",\n                \"createdbefore\",\n                \"creator\",\n                \"department\",\n                \"documentcategory\",\n                \"epicstatus\",\n                \"featuresize\",\n                \"feedbackfrom\",\n                \"from\",\n                \"has\",\n                \"in\",\n                \"industry\",\n                \"issuetype\",\n                \"label\",\n                \"launchtierformarketingsetbyproducttorequestmarketingsupportmarketingtoverify\",\n                \"launchvisibilitysetbyproducteng\",\n                \"location\",\n                \"mentions\",\n                \"my\",\n                \"owner\",\n                \"priority\",\n                \"product\",\n                \"productmarketingmanagerpmm\",\n                \"project\",\n                \"quarter\",\n                \"region\",\n                \"reporter\",\n                \"reportsto\",\n                \"resolution\",\n                \"resolutionets\",\n                \"roadmap\",\n                \"roletype\",\n                \"rootcauseets\",\n                \"sortby\",\n                \"sprint\",\n                \"startafter\",\n                \"startbefore\",\n                \"state\",\n                \"status\",\n                \"statuscategory\",\n                \"tag\",\n                \"team\",\n                \"title\",\n                \"type\",\n                \"updated\",\n                \"urgency\",\n                \"with\",\n                \"workstream\",\n            },\n            \"slack\": {\n                \"after\",\n                \"app\",\n                \"appinstance\",\n                \"author\",\n                \"before\",\n                \"businessunit\",\n                \"channel\",\n                \"city\",\n                \"collection\",\n                \"country\",\n                \"created\",\n                \"createdafter\",\n                \"createdbefore\",\n                \"department\",\n                \"documentcategory\",\n                \"from\",\n                \"has\",\n                \"in\",\n                \"industry\",\n                \"location\",\n                \"mentions\",\n                \"my\",\n                \"owner\",\n                \"region\",\n                \"reportsto\",\n                \"roletype\",\n                \"sortby\",\n                \"startafter\",\n                \"startbefore\",\n                \"state\",\n                \"status\",\n                \"title\",\n                \"type\",\n                \"updated\",\n                \"visibility\",\n                \"with\",\n                \"workspace\",\n            },\n            \"gong\": {\n                \"account\",\n                \"after\",\n                \"app\",\n                \"author\",\n                \"before\",\n                \"businessunit\",\n                \"city\",\n                \"collection\",\n                \"country\",\n                \"created\",\n                \"createdafter\",\n                \"createdbefore\",\n                \"department\",\n                \"documentcategory\",\n                \"from\",\n                \"has\",\n                \"industry\",\n                \"location\",\n                \"my\",\n                \"owner\",\n                \"participants\",\n                \"region\",\n                \"reportsto\",\n                \"roletype\",\n                \"sortby\",\n                \"startafter\",\n                \"startbefore\",\n                \"state\",\n                \"title\",\n                \"type\",\n                \"updated\",\n                \"with\",\n            },\n            \"drive\": {\n                \"after\",\n                \"app\",\n                \"appinstance\",\n                \"author\",\n                \"before\",\n                \"businessunit\",\n                \"city\",\n                \"collection\",\n                \"country\",\n                \"created\",\n                \"createdafter\",\n                \"createdbefore\",\n                \"department\",\n                \"documentcategory\",\n                \"editor\",\n                \"folder\",\n                \"from\",\n                \"has\",\n                \"in\",\n                \"industry\",\n                \"location\",\n                \"mentions\",\n                \"my\",\n                \"owner\",\n                \"region\",\n                \"reportsto\",\n                \"roletype\",\n                \"sortby\",\n                \"startafter\",\n                \"startbefore\",\n                \"state\",\n                \"title\",\n                \"type\",\n                \"updated\",\n                \"with\",\n            },\n            \"confluence\": {\n                \"after\",\n                \"app\",\n                \"appinstance\",\n                \"author\",\n                \"before\",\n                \"businessunit\",\n                \"city\",\n                \"collection\",\n                \"commenter\",\n                \"country\",\n                \"created\",\n                \"createdafter\",\n                \"createdbefore\",\n                \"department\",\n                \"documentcategory\",\n                \"editor\",\n                \"from\",\n                \"has\",\n                \"in\",\n                \"industry\",\n                \"label\",\n                \"location\",\n                \"mentions\",\n                \"my\",\n                \"owner\",\n                \"region\",\n                \"reportsto\",\n                \"roletype\",\n                \"sortby\",\n                \"space\",\n                \"startafter\",\n                \"startbefore\",\n                \"state\",\n                \"status\",\n                \"tag\",\n                \"title\",\n                \"type\",\n                \"updated\",\n                \"with\",\n            },\n            \"answers\": {\n                \"after\",\n                \"app\",\n                \"author\",\n                \"before\",\n                \"board\",\n                \"businessunit\",\n                \"city\",\n                \"collection\",\n                \"country\",\n                \"created\",\n                \"createdafter\",\n                \"createdbefore\",\n                \"creator\",\n                \"department\",\n                \"documentcategory\",\n                \"from\",\n                \"has\",\n                \"in\",\n                \"industry\",\n                \"label\",\n                \"location\",\n                \"mentions\",\n                \"my\",\n                \"owner\",\n                \"region\",\n                \"reportsto\",\n                \"roletype\",\n                \"sortby\",\n                \"startafter\",\n                \"startbefore\",\n                \"state\",\n                \"tag\",\n                \"title\",\n                \"type\",\n                \"updated\",\n                \"with\",\n            },\n        }\n\n    def is_valid_time_reference(self, s: str) -> bool:\n        if not s:\n            return False\n\n        s = s.strip()\n\n        patterns = [\n            # Relative time patterns\n            r\"^past_\\d+_(hours|days|weeks|months|years)$\",\n            r\"^past_(day|week|month|year|quarter|hour|weekend)$\",\n            r\"^past_few_(days|months)$\",\n            r\"^(this|next|last)_week$\",\n            r\"^(today|yesterday|tomorrow|recent)$\",\n            r\"^THIS_FISCAL_QUARTER$\",\n            r\"^annual$\",\n            # Days of the week\n            r\"^(Monday|Mon|Tuesday|Tues?|Wednesday|Wed|Thursday|Thurs?|Friday|Fri|Saturday|Sat|Sunday|Sun)$\",\n            # Calendar dates\n            r\"^\\d{4}-\\d{2}-\\d{2}$\",  # YYYY-MM-DD\n            r\"^\\d{4}-\\d{2}$\",  # YYYY-MM\n            r\"^\\d{4}$\",  # YYYY\n            # Months (including abbreviations)\n            r\"^(January|Jan|February|Feb|March|Mar|April|Apr|May|June|Jun|July|Jul|August|Aug|September|Sept?|October|Oct|November|Nov|December|Dec)$\",\n            r\"^(January|Jan|February|Feb|March|Mar|April|Apr|May|June|Jun|July|Jul|August|Aug|September|Sept?|October|Oct|November|Nov|December|Dec)-\\d{4}$\",\n            # Range operators\n            r\"^(before|after):\\d{4}-\\d{2}-\\d{2}$\",\n            r\"^\\d{4}-\\d{2}-\\d{2}\\.\\.\\d{4}-\\d{2}-\\d{2}$\",\n        ]\n\n        return any(re.match(pattern, s, re.IGNORECASE) for pattern in patterns)\n\n    def is_valid_app_name(self, s: str) -> bool:\n        patterns = [\n            # Common apps with exact names\n            r\"^(customer|slack|jira|github|email|glean|gong|gmail|loom|asana|gitlab|githubenterprise|confluence|zendesk|figma|metabase|linkedin|okta|notion|bazel|azure|miro|sigma|twitter)$\",\n            # Apps that might have variations\n            r\"^(google\\s*(drive|calendar|slides)|microsoft\\s*teams|ms\\s*teams|sharepoint|g(cal|drive|chat))$\",\n            # Services with common prefixes\n            r\"^(sales|service)cloud$\",\n            r\"^(app\\s*builder|glean\\s*(support|website|assistant)|sales\\s*cloud|service\\s*cloud)$\",\n        ]\n\n        # Convert to lowercase for matching\n        s = s.lower().strip()\n\n        # Ignore malformed entries with quotes or brackets\n        if any(char in s for char in '\"[]\\\\'):\n            return False\n\n        return any(re.match(pattern, s, re.IGNORECASE) for pattern in patterns)\n\n    def is_valid_type(self, s: str) -> bool:\n        patterns = [\n            # Common document types\n            r\"^(document|spreadsheet|presentation|pdf|file|doc|slides|form|image|video)$\",\n            # Code/development related\n            r\"^(pull|pr|commit|repo|code|component|issue|bug)$\",\n            # Project management\n            r\"^(project|task|epic|story|ticket|release|case)$\",\n            # Communication types\n            r\"^(meeting|call|message|thread|conversation|direct_message|announcement)$\",\n            # Business/CRM related\n            r\"^(opportunity|account|contact)$\",\n            # Storage/organization\n            r\"^(folder|dir|collection|table)$\",\n            # Knowledge/content\n            r\"^(article|blog|answer|description)$\",\n        ]\n\n        # Convert to lowercase for matching\n        s = s.lower().strip()\n\n        # Ignore malformed entries with quotes or brackets\n        if any(char in s for char in '\"[]\\\\'):\n            return False\n\n        return any(re.match(pattern, s, re.IGNORECASE) for pattern in patterns)\n\n    def is_valid_status(self, s: str) -> bool:\n        patterns = [\n            # Common status states\n            r\"^(open|closed|merged|draft|pending|solved|assigned|submitted)$\",\n            # Business outcomes\n            r\"^(won|closed[\\s-]won)$\",\n            # Project stages\n            r\"^(beta|backlog|in\\s*roadmap|scheduled\\/in\\s*roadmap|to\\s*do|qa\\s*fr\\s*complete)$\",\n            # Special states\n            r\"^(hold|unread|outstanding|parking)$\",\n        ]\n\n        # Convert to lowercase and clean\n        s = s.lower().strip()\n\n        # Ignore entries with quotes or brackets\n        if any(char in s for char in '\"[]\\\\'):\n            return False\n\n        return any(re.match(pattern, s, re.IGNORECASE) for pattern in patterns)\n\n    def is_valid_status_category(self, s: str) -> bool:\n        patterns = [\n            # Common status categories\n            r\"^(in_progress|to_do|todo|done|blocked|backlog|in_review)$\",\n        ]\n\n        # Convert to lowercase and normalize\n        s = s.lower().strip().replace(\" \", \"_\")\n\n        return any(re.match(pattern, s, re.IGNORECASE) for pattern in patterns)\n\n    def is_valid_document_category(self, s: str) -> bool:\n        patterns = [\n            # Common status categories\n            r\"^(tickets|messaging|code_repository)$\",\n        ]\n\n        # Convert to lowercase and normalize\n        s = s.lower().strip().replace(\" \", \"_\")\n\n        return any(re.match(pattern, s, re.IGNORECASE) for pattern in patterns)\n\n    def is_valid_name(self, s: str) -> bool:\n        patterns = [\n            # General email pattern (username@domain.com)\n            r\"^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$\",\n            # Email pattern which accepts: mailto:\n            r\"^(?:mailto:)?[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$\",\n            # Full names (First Last or First)\n            r\"^[A-Z][a-z]+(\\s+[A-Z][a-z]+)*$\",  # Capitalized words\n            r\"^[a-z]+$\",  # Single lowercase name\n            # Dot-separated names (First.Last)\n            r\"^[A-Z][a-z]+\\.[A-Z][a-z]+$\",  # Like Hannah.Abouchar\n            # Special assignees\n            r\"^(me)$\",\n            # Team names\n            r\"^[a-z\\s]+ team$\",  # like \"front end team\"\n        ]\n\n        # Clean the input\n        s = s.strip()\n        return any(re.match(pattern, s, re.IGNORECASE) for pattern in patterns)\n\n    def is_valid_input_for_channel(self, s: str) -> bool:\n        patterns = [\n            r\"#\\S+\",  # Match # followed by any non-whitespace characters, anywhere in string\n            r\"channel\",  # Match 'channel' anywhere in string\n        ]\n\n        # Convert to lowercase and normalize\n        s = s.lower().strip()\n\n        return any(re.search(pattern, s, re.IGNORECASE) for pattern in patterns)\n\n    def is_valid_input_for_label(self, s: str) -> bool:\n        patterns = [\n            r\"label\"  # Match 'label' anywhere in string\n        ]\n\n        # Convert to lowercase and normalize\n        s = s.lower().strip()\n\n        return any(re.search(pattern, s, re.IGNORECASE) for pattern in patterns)\n\n    def filter_database_check(self, input_text, output_text):\n        for key, val in self._parse_query(output_text)[0].items():\n            if key == \"app\":\n                if not self.is_valid_app_name(val):\n                    return 0.0, \"bad app value: \" + val\n\n            if key == \"documentcategory\":\n                if not self.is_valid_document_category(val):\n                    return 0.0, \"bad document category: \" + val\n\n            if key == \"type\":\n                if not self.is_valid_type(val):\n                    return 0.0, \"bad type: \" + val\n\n            if (\n                key == \"updated\"\n                or key == \"after\"\n                or key == \"before\"\n                or key == \"created\"\n                or key == \"createdafter\"\n                or key == \"createdbefore\"\n            ):\n                if not self.is_valid_time_reference(val):\n                    return 0.0, \"bad time reference format: \" + val\n\n            if (\n                key == \"from\"\n                or key == \"author\"\n                or key == \"owner\"\n                or key == \"reporter\"\n                or key == \"assignee\"\n            ):\n                if not self.is_valid_name(val):\n                    return 0.0, \"bad name or alias or entity: \" + val\n\n            if key == \"status\":\n                if not self.is_valid_status(val):\n                    return 0.0, \"bad status value: \" + val\n\n            if key == \"statuscategory\":\n                if not self.is_valid_status_category(val):\n                    return 0.0, \"bad status category: \" + val\n\n            if key == \"channel\":\n                if not self.is_valid_input_for_channel(input_text):\n                    return 0.0, \"no explicit ask for channel in the input\"\n\n            if key == \"label\":\n                if not self.is_valid_input_for_label(input_text):\n                    return 0.0, \"no explicit ask for label in the input\"\n\n        return 1.0, \"all good filters\"\n\n    def evaluate(\n        self,\n        input_text: str,\n        response_text: str,\n    ) -> dict:\n        score = 1.0\n        explanations = []\n        app_name = \"\"\n        label_score = {}\n\n        filter_and_value, error_msg = self._parse_query(response_text)\n        if error_msg != \"\":\n            score = 0.0\n            explanations.append(error_msg)\n            label_score[\"Output Format\"] = 0\n        if \"app\" in filter_and_value:\n            app_name = filter_and_value[\"app\"]\n\n        unknown_filters = []\n        for filter, value in filter_and_value.items():\n            if value == \"\":\n                score = 0.0\n                explanations.append(\"Empty filter value: \" + filter)\n                label_score[\"Output Format\"] = 0\n\n            if filter not in self.all_filters:\n                unknown_filters.append(filter)\n\n            if app_name != \"\" and filter != \"app\":\n                if app_name not in self.app_filters:\n                    # We don't have list of filters for this app.\n                    continue\n                if filter not in self.app_filters[app_name]:\n                    score = 0.0\n                    explanations.append(\n                        \"App: \" + app_name + \" cannot use the filter: \" + filter\n                    )\n                    label_score[\"App Compatibility\"] = 0\n\n        if len(unknown_filters) > 0:\n            score = 0.0\n            explanations.append(\"Unknown Filter: \" + \", \".join(unknown_filters))\n            label_score[\"Unknown Filters\"] = 0\n\n        d_score, d_expl = self.filter_database_check(input_text, response_text)\n        label_score[\"Filter Database Compliance\"] = d_score\n\n        if d_score < 1.0:\n            score = 0.0\n            explanations.append(d_expl)\n\n        # Only check the conditions corresponding to the dimension with self.label.\n        final_score = score if self.label == \"\" else label_score.get(self.label, 1.0)\n\n        return {\"score\": final_score, \"explanation\": \" | \".join(explanations)}\n\n\ndef score(\n    response_text: str,\n    input_text: str,\n    input_args: dict[str, Any],\n    kwargs: dict[str, Any],\n) -> dict:\n    scorer = GleanScorer(**kwargs)\n    return scorer.evaluate(input_text, response_text)\n",
                    "custom_model_id": null,
                    "parameters": null,
                    "weight": 1.0,
                    "action_dimension": null
                },
                {
                    "label": "Unknown Filters",
                    "description": "Are the filters used in the response contained in the list of all the filters we have?",
                    "scoring_type": "PYTHON_CODE",
                    "python_code": "from typing import Any, Dict\nimport re\nfrom importlib.resources import files\n\n\nclass GleanScorer:\n    def _parse_query(self, query) -> tuple[dict[str, str], str]:\n        \"\"\"\n        Parse a query string into a dictionary of key-value pairs.\n\n        Args:\n            query (str): Query string to parse\n\n        Returns:\n            Dict[str, str]: Dictionary of parsed key-value pairs\n            str: Error msg which is basically duplicate filters\n        \"\"\"\n        # Pattern matches:\n        # 1. key:\"value with spaces\"    (double quoted values)\n        # 2. key:'value with spaces'    (single quoted values)\n        # 3. key:value                  (unquoted values without spaces)\n        # 4. key:                       (empty values)\n        pattern = r'(\\w+):(?:\"([^\"]+)\"|\\'([^\\']+)\\'|([^\\s]*))'\n\n        matches = re.finditer(pattern, query)\n        parsed = {}\n        error_msg = \"\"\n\n        for match in matches:\n            key = match.group(1)  # The operator/key\n            # Check each possible group (quoted double, quoted single, unquoted)\n            value = match.group(2) or match.group(3) or match.group(4) or \"\"\n            if key.lower() in parsed and value == parsed[key.lower()]:\n                error_msg = \"Duplicates for the filter: \" + key.lower()\n\n            parsed[key.lower()] = value\n\n        return parsed, error_msg\n\n    def __init__(self, **kwargs):\n        # Same function is used for all the glean dimension / nodes. The label tells us which node this current function invocation should act as.\n        # If the label is empty, the same run is going to check all the conditions for all the glean python dimensions / nodes.\n        self.label = kwargs.get(\"label\", \"\")\n        self.all_filters = {\n            \"app\",\n            \"documentcategory\",\n            \"type\",\n            \"updated\",\n            \"after\",\n            \"before\",\n            \"created\",\n            \"createdafter\",\n            \"createdbefore\",\n            \"from\",\n            \"author\",\n            \"owner\",\n            \"reporter\",\n            \"assignee\",\n            \"label\",\n            \"component\",\n            \"status\",\n            \"statuscategory\",\n            \"channel\",\n        }\n        self.app_filters = {\n            \"github\": {\n                \"after\",\n                \"app\",\n                \"assignee\",\n                \"author\",\n                \"before\",\n                \"businessunit\",\n                \"city\",\n                \"collection\",\n                \"commenter\",\n                \"country\",\n                \"created\",\n                \"createdafter\",\n                \"createdbefore\",\n                \"department\",\n                \"documentcategory\",\n                \"from\",\n                \"has\",\n                \"in\",\n                \"industry\",\n                \"label\",\n                \"location\",\n                \"mentions\",\n                \"my\",\n                \"organization\",\n                \"owner\",\n                \"region\",\n                \"reportsto\",\n                \"repository\",\n                \"reviewer\",\n                \"roletype\",\n                \"sortby\",\n                \"startafter\",\n                \"startbefore\",\n                \"state\",\n                \"status\",\n                \"title\",\n                \"type\",\n                \"updated\",\n                \"with\",\n            },\n            \"jira\": {\n                \"after\",\n                \"app\",\n                \"assignee\",\n                \"before\",\n                \"businessunit\",\n                \"category\",\n                \"changerisk\",\n                \"city\",\n                \"collection\",\n                \"commenter\",\n                \"component\",\n                \"connectorrequesttype\",\n                \"country\",\n                \"created\",\n                \"createdafter\",\n                \"createdbefore\",\n                \"creator\",\n                \"department\",\n                \"documentcategory\",\n                \"epicstatus\",\n                \"featuresize\",\n                \"feedbackfrom\",\n                \"from\",\n                \"has\",\n                \"in\",\n                \"industry\",\n                \"issuetype\",\n                \"label\",\n                \"launchtierformarketingsetbyproducttorequestmarketingsupportmarketingtoverify\",\n                \"launchvisibilitysetbyproducteng\",\n                \"location\",\n                \"mentions\",\n                \"my\",\n                \"owner\",\n                \"priority\",\n                \"product\",\n                \"productmarketingmanagerpmm\",\n                \"project\",\n                \"quarter\",\n                \"region\",\n                \"reporter\",\n                \"reportsto\",\n                \"resolution\",\n                \"resolutionets\",\n                \"roadmap\",\n                \"roletype\",\n                \"rootcauseets\",\n                \"sortby\",\n                \"sprint\",\n                \"startafter\",\n                \"startbefore\",\n                \"state\",\n                \"status\",\n                \"statuscategory\",\n                \"tag\",\n                \"team\",\n                \"title\",\n                \"type\",\n                \"updated\",\n                \"urgency\",\n                \"with\",\n                \"workstream\",\n            },\n            \"slack\": {\n                \"after\",\n                \"app\",\n                \"appinstance\",\n                \"author\",\n                \"before\",\n                \"businessunit\",\n                \"channel\",\n                \"city\",\n                \"collection\",\n                \"country\",\n                \"created\",\n                \"createdafter\",\n                \"createdbefore\",\n                \"department\",\n                \"documentcategory\",\n                \"from\",\n                \"has\",\n                \"in\",\n                \"industry\",\n                \"location\",\n                \"mentions\",\n                \"my\",\n                \"owner\",\n                \"region\",\n                \"reportsto\",\n                \"roletype\",\n                \"sortby\",\n                \"startafter\",\n                \"startbefore\",\n                \"state\",\n                \"status\",\n                \"title\",\n                \"type\",\n                \"updated\",\n                \"visibility\",\n                \"with\",\n                \"workspace\",\n            },\n            \"gong\": {\n                \"account\",\n                \"after\",\n                \"app\",\n                \"author\",\n                \"before\",\n                \"businessunit\",\n                \"city\",\n                \"collection\",\n                \"country\",\n                \"created\",\n                \"createdafter\",\n                \"createdbefore\",\n                \"department\",\n                \"documentcategory\",\n                \"from\",\n                \"has\",\n                \"industry\",\n                \"location\",\n                \"my\",\n                \"owner\",\n                \"participants\",\n                \"region\",\n                \"reportsto\",\n                \"roletype\",\n                \"sortby\",\n                \"startafter\",\n                \"startbefore\",\n                \"state\",\n                \"title\",\n                \"type\",\n                \"updated\",\n                \"with\",\n            },\n            \"drive\": {\n                \"after\",\n                \"app\",\n                \"appinstance\",\n                \"author\",\n                \"before\",\n                \"businessunit\",\n                \"city\",\n                \"collection\",\n                \"country\",\n                \"created\",\n                \"createdafter\",\n                \"createdbefore\",\n                \"department\",\n                \"documentcategory\",\n                \"editor\",\n                \"folder\",\n                \"from\",\n                \"has\",\n                \"in\",\n                \"industry\",\n                \"location\",\n                \"mentions\",\n                \"my\",\n                \"owner\",\n                \"region\",\n                \"reportsto\",\n                \"roletype\",\n                \"sortby\",\n                \"startafter\",\n                \"startbefore\",\n                \"state\",\n                \"title\",\n                \"type\",\n                \"updated\",\n                \"with\",\n            },\n            \"confluence\": {\n                \"after\",\n                \"app\",\n                \"appinstance\",\n                \"author\",\n                \"before\",\n                \"businessunit\",\n                \"city\",\n                \"collection\",\n                \"commenter\",\n                \"country\",\n                \"created\",\n                \"createdafter\",\n                \"createdbefore\",\n                \"department\",\n                \"documentcategory\",\n                \"editor\",\n                \"from\",\n                \"has\",\n                \"in\",\n                \"industry\",\n                \"label\",\n                \"location\",\n                \"mentions\",\n                \"my\",\n                \"owner\",\n                \"region\",\n                \"reportsto\",\n                \"roletype\",\n                \"sortby\",\n                \"space\",\n                \"startafter\",\n                \"startbefore\",\n                \"state\",\n                \"status\",\n                \"tag\",\n                \"title\",\n                \"type\",\n                \"updated\",\n                \"with\",\n            },\n            \"answers\": {\n                \"after\",\n                \"app\",\n                \"author\",\n                \"before\",\n                \"board\",\n                \"businessunit\",\n                \"city\",\n                \"collection\",\n                \"country\",\n                \"created\",\n                \"createdafter\",\n                \"createdbefore\",\n                \"creator\",\n                \"department\",\n                \"documentcategory\",\n                \"from\",\n                \"has\",\n                \"in\",\n                \"industry\",\n                \"label\",\n                \"location\",\n                \"mentions\",\n                \"my\",\n                \"owner\",\n                \"region\",\n                \"reportsto\",\n                \"roletype\",\n                \"sortby\",\n                \"startafter\",\n                \"startbefore\",\n                \"state\",\n                \"tag\",\n                \"title\",\n                \"type\",\n                \"updated\",\n                \"with\",\n            },\n        }\n\n    def is_valid_time_reference(self, s: str) -> bool:\n        if not s:\n            return False\n\n        s = s.strip()\n\n        patterns = [\n            # Relative time patterns\n            r\"^past_\\d+_(hours|days|weeks|months|years)$\",\n            r\"^past_(day|week|month|year|quarter|hour|weekend)$\",\n            r\"^past_few_(days|months)$\",\n            r\"^(this|next|last)_week$\",\n            r\"^(today|yesterday|tomorrow|recent)$\",\n            r\"^THIS_FISCAL_QUARTER$\",\n            r\"^annual$\",\n            # Days of the week\n            r\"^(Monday|Mon|Tuesday|Tues?|Wednesday|Wed|Thursday|Thurs?|Friday|Fri|Saturday|Sat|Sunday|Sun)$\",\n            # Calendar dates\n            r\"^\\d{4}-\\d{2}-\\d{2}$\",  # YYYY-MM-DD\n            r\"^\\d{4}-\\d{2}$\",  # YYYY-MM\n            r\"^\\d{4}$\",  # YYYY\n            # Months (including abbreviations)\n            r\"^(January|Jan|February|Feb|March|Mar|April|Apr|May|June|Jun|July|Jul|August|Aug|September|Sept?|October|Oct|November|Nov|December|Dec)$\",\n            r\"^(January|Jan|February|Feb|March|Mar|April|Apr|May|June|Jun|July|Jul|August|Aug|September|Sept?|October|Oct|November|Nov|December|Dec)-\\d{4}$\",\n            # Range operators\n            r\"^(before|after):\\d{4}-\\d{2}-\\d{2}$\",\n            r\"^\\d{4}-\\d{2}-\\d{2}\\.\\.\\d{4}-\\d{2}-\\d{2}$\",\n        ]\n\n        return any(re.match(pattern, s, re.IGNORECASE) for pattern in patterns)\n\n    def is_valid_app_name(self, s: str) -> bool:\n        patterns = [\n            # Common apps with exact names\n            r\"^(customer|slack|jira|github|email|glean|gong|gmail|loom|asana|gitlab|githubenterprise|confluence|zendesk|figma|metabase|linkedin|okta|notion|bazel|azure|miro|sigma|twitter)$\",\n            # Apps that might have variations\n            r\"^(google\\s*(drive|calendar|slides)|microsoft\\s*teams|ms\\s*teams|sharepoint|g(cal|drive|chat))$\",\n            # Services with common prefixes\n            r\"^(sales|service)cloud$\",\n            r\"^(app\\s*builder|glean\\s*(support|website|assistant)|sales\\s*cloud|service\\s*cloud)$\",\n        ]\n\n        # Convert to lowercase for matching\n        s = s.lower().strip()\n\n        # Ignore malformed entries with quotes or brackets\n        if any(char in s for char in '\"[]\\\\'):\n            return False\n\n        return any(re.match(pattern, s, re.IGNORECASE) for pattern in patterns)\n\n    def is_valid_type(self, s: str) -> bool:\n        patterns = [\n            # Common document types\n            r\"^(document|spreadsheet|presentation|pdf|file|doc|slides|form|image|video)$\",\n            # Code/development related\n            r\"^(pull|pr|commit|repo|code|component|issue|bug)$\",\n            # Project management\n            r\"^(project|task|epic|story|ticket|release|case)$\",\n            # Communication types\n            r\"^(meeting|call|message|thread|conversation|direct_message|announcement)$\",\n            # Business/CRM related\n            r\"^(opportunity|account|contact)$\",\n            # Storage/organization\n            r\"^(folder|dir|collection|table)$\",\n            # Knowledge/content\n            r\"^(article|blog|answer|description)$\",\n        ]\n\n        # Convert to lowercase for matching\n        s = s.lower().strip()\n\n        # Ignore malformed entries with quotes or brackets\n        if any(char in s for char in '\"[]\\\\'):\n            return False\n\n        return any(re.match(pattern, s, re.IGNORECASE) for pattern in patterns)\n\n    def is_valid_status(self, s: str) -> bool:\n        patterns = [\n            # Common status states\n            r\"^(open|closed|merged|draft|pending|solved|assigned|submitted)$\",\n            # Business outcomes\n            r\"^(won|closed[\\s-]won)$\",\n            # Project stages\n            r\"^(beta|backlog|in\\s*roadmap|scheduled\\/in\\s*roadmap|to\\s*do|qa\\s*fr\\s*complete)$\",\n            # Special states\n            r\"^(hold|unread|outstanding|parking)$\",\n        ]\n\n        # Convert to lowercase and clean\n        s = s.lower().strip()\n\n        # Ignore entries with quotes or brackets\n        if any(char in s for char in '\"[]\\\\'):\n            return False\n\n        return any(re.match(pattern, s, re.IGNORECASE) for pattern in patterns)\n\n    def is_valid_status_category(self, s: str) -> bool:\n        patterns = [\n            # Common status categories\n            r\"^(in_progress|to_do|todo|done|blocked|backlog|in_review)$\",\n        ]\n\n        # Convert to lowercase and normalize\n        s = s.lower().strip().replace(\" \", \"_\")\n\n        return any(re.match(pattern, s, re.IGNORECASE) for pattern in patterns)\n\n    def is_valid_document_category(self, s: str) -> bool:\n        patterns = [\n            # Common status categories\n            r\"^(tickets|messaging|code_repository)$\",\n        ]\n\n        # Convert to lowercase and normalize\n        s = s.lower().strip().replace(\" \", \"_\")\n\n        return any(re.match(pattern, s, re.IGNORECASE) for pattern in patterns)\n\n    def is_valid_name(self, s: str) -> bool:\n        patterns = [\n            # General email pattern (username@domain.com)\n            r\"^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$\",\n            # Email pattern which accepts: mailto:\n            r\"^(?:mailto:)?[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$\",\n            # Full names (First Last or First)\n            r\"^[A-Z][a-z]+(\\s+[A-Z][a-z]+)*$\",  # Capitalized words\n            r\"^[a-z]+$\",  # Single lowercase name\n            # Dot-separated names (First.Last)\n            r\"^[A-Z][a-z]+\\.[A-Z][a-z]+$\",  # Like Hannah.Abouchar\n            # Special assignees\n            r\"^(me)$\",\n            # Team names\n            r\"^[a-z\\s]+ team$\",  # like \"front end team\"\n        ]\n\n        # Clean the input\n        s = s.strip()\n        return any(re.match(pattern, s, re.IGNORECASE) for pattern in patterns)\n\n    def is_valid_input_for_channel(self, s: str) -> bool:\n        patterns = [\n            r\"#\\S+\",  # Match # followed by any non-whitespace characters, anywhere in string\n            r\"channel\",  # Match 'channel' anywhere in string\n        ]\n\n        # Convert to lowercase and normalize\n        s = s.lower().strip()\n\n        return any(re.search(pattern, s, re.IGNORECASE) for pattern in patterns)\n\n    def is_valid_input_for_label(self, s: str) -> bool:\n        patterns = [\n            r\"label\"  # Match 'label' anywhere in string\n        ]\n\n        # Convert to lowercase and normalize\n        s = s.lower().strip()\n\n        return any(re.search(pattern, s, re.IGNORECASE) for pattern in patterns)\n\n    def filter_database_check(self, input_text, output_text):\n        for key, val in self._parse_query(output_text)[0].items():\n            if key == \"app\":\n                if not self.is_valid_app_name(val):\n                    return 0.0, \"bad app value: \" + val\n\n            if key == \"documentcategory\":\n                if not self.is_valid_document_category(val):\n                    return 0.0, \"bad document category: \" + val\n\n            if key == \"type\":\n                if not self.is_valid_type(val):\n                    return 0.0, \"bad type: \" + val\n\n            if (\n                key == \"updated\"\n                or key == \"after\"\n                or key == \"before\"\n                or key == \"created\"\n                or key == \"createdafter\"\n                or key == \"createdbefore\"\n            ):\n                if not self.is_valid_time_reference(val):\n                    return 0.0, \"bad time reference format: \" + val\n\n            if (\n                key == \"from\"\n                or key == \"author\"\n                or key == \"owner\"\n                or key == \"reporter\"\n                or key == \"assignee\"\n            ):\n                if not self.is_valid_name(val):\n                    return 0.0, \"bad name or alias or entity: \" + val\n\n            if key == \"status\":\n                if not self.is_valid_status(val):\n                    return 0.0, \"bad status value: \" + val\n\n            if key == \"statuscategory\":\n                if not self.is_valid_status_category(val):\n                    return 0.0, \"bad status category: \" + val\n\n            if key == \"channel\":\n                if not self.is_valid_input_for_channel(input_text):\n                    return 0.0, \"no explicit ask for channel in the input\"\n\n            if key == \"label\":\n                if not self.is_valid_input_for_label(input_text):\n                    return 0.0, \"no explicit ask for label in the input\"\n\n        return 1.0, \"all good filters\"\n\n    def evaluate(\n        self,\n        input_text: str,\n        response_text: str,\n    ) -> dict:\n        score = 1.0\n        explanations = []\n        app_name = \"\"\n        label_score = {}\n\n        filter_and_value, error_msg = self._parse_query(response_text)\n        if error_msg != \"\":\n            score = 0.0\n            explanations.append(error_msg)\n            label_score[\"Output Format\"] = 0\n        if \"app\" in filter_and_value:\n            app_name = filter_and_value[\"app\"]\n\n        unknown_filters = []\n        for filter, value in filter_and_value.items():\n            if value == \"\":\n                score = 0.0\n                explanations.append(\"Empty filter value: \" + filter)\n                label_score[\"Output Format\"] = 0\n\n            if filter not in self.all_filters:\n                unknown_filters.append(filter)\n\n            if app_name != \"\" and filter != \"app\":\n                if app_name not in self.app_filters:\n                    # We don't have list of filters for this app.\n                    continue\n                if filter not in self.app_filters[app_name]:\n                    score = 0.0\n                    explanations.append(\n                        \"App: \" + app_name + \" cannot use the filter: \" + filter\n                    )\n                    label_score[\"App Compatibility\"] = 0\n\n        if len(unknown_filters) > 0:\n            score = 0.0\n            explanations.append(\"Unknown Filter: \" + \", \".join(unknown_filters))\n            label_score[\"Unknown Filters\"] = 0\n\n        d_score, d_expl = self.filter_database_check(input_text, response_text)\n        label_score[\"Filter Database Compliance\"] = d_score\n\n        if d_score < 1.0:\n            score = 0.0\n            explanations.append(d_expl)\n\n        # Only check the conditions corresponding to the dimension with self.label.\n        final_score = score if self.label == \"\" else label_score.get(self.label, 1.0)\n\n        return {\"score\": final_score, \"explanation\": \" | \".join(explanations)}\n\n\ndef score(\n    response_text: str,\n    input_text: str,\n    input_args: dict[str, Any],\n    kwargs: dict[str, Any],\n) -> dict:\n    scorer = GleanScorer(**kwargs)\n    return scorer.evaluate(input_text, response_text)\n",
                    "custom_model_id": null,
                    "parameters": null,
                    "weight": 1.0,
                    "action_dimension": null
                }
            ],
            "action_dimension": {
                "label": "Direct Score Calculation Eligibility",
                "description": "Is the score directly calculatable?",
                "scoring_type": "CUSTOM_MODEL_SCORER",
                "python_code": null,
                "custom_model_id": "glean-dimension-scoring",
                "action_on_low_score": true
            }
        },
        {
            "label": "Query Construction Semantics",
            "description": "How can search queries be constructed effectively?",
            "weight": 1.0,
            "sub_dimensions": [
                {
                    "label": "Query Construction",
                    "description": "Is the response a semi-structured query generated based on the user's query?",
                    "scoring_type": "PI_SCORER",
                    "python_code": null,
                    "custom_model_id": null,
                    "parameters": null,
                    "weight": 1.0,
                    "action_dimension": null
                },
                {
                    "label": "Keyword Inclusion",
                    "description": "Are all the required keywords (non-stop-words) from the user's query included in the search query?",
                    "scoring_type": "PI_SCORER",
                    "python_code": null,
                    "custom_model_id": null,
                    "parameters": null,
                    "weight": 1.0,
                    "action_dimension": null
                },
                {
                    "label": "Query Optimization",
                    "description": "Is the generated search query optimized for retrieving the most relevant documents?",
                    "scoring_type": "PI_SCORER",
                    "python_code": null,
                    "custom_model_id": null,
                    "parameters": null,
                    "weight": 1.0,
                    "action_dimension": null
                }
            ],
            "action_dimension": {
                "label": "Direct Score Calculation Eligibility",
                "description": "Is the score directly calculatable?",
                "scoring_type": "CUSTOM_MODEL_SCORER",
                "python_code": null,
                "custom_model_id": "glean-dimension-scoring",
                "action_on_low_score": true
            }
        },
        {
            "label": "Filter Application",
            "description": "How should filters be applied to refine search results?",
            "weight": 1.0,
            "sub_dimensions": [
                {
                    "label": "channel Filter Usage",
                    "description": "Is 'channel' filter used when user query searches for items belonging to a specific channel?",
                    "scoring_type": "PI_SCORER",
                    "python_code": null,
                    "custom_model_id": null,
                    "parameters": null,
                    "weight": 1.0,
                    "action_dimension": {
                        "label": "channel Filter Eligibility",
                        "description": "Is the use of 'channel' filter necessary to answer the user quey?",
                        "scoring_type": "PI_SCORER",
                        "python_code": null,
                        "custom_model_id": null,
                        "action_on_low_score": false
                    }
                },
                {
                    "label": "created Filter Usage",
                    "description": "Is 'created' filter used when user query searches for items created on a specific date or time?",
                    "scoring_type": "PI_SCORER",
                    "python_code": null,
                    "custom_model_id": null,
                    "parameters": null,
                    "weight": 1.0,
                    "action_dimension": {
                        "label": "created Filter Eligibility",
                        "description": "Is the use of 'created' filter necessary to answer the user quey?",
                        "scoring_type": "PI_SCORER",
                        "python_code": null,
                        "custom_model_id": null,
                        "action_on_low_score": false
                    }
                },
                {
                    "label": "createdbefore Filter Usage",
                    "description": "Is 'createdbefore' filter used when user query searches for items created before a specific date or time?",
                    "scoring_type": "PI_SCORER",
                    "python_code": null,
                    "custom_model_id": null,
                    "parameters": null,
                    "weight": 1.0,
                    "action_dimension": {
                        "label": "createdbefore Filter Eligibility",
                        "description": "Is the use of 'createdbefore' filter necessary to answer the user quey?",
                        "scoring_type": "PI_SCORER",
                        "python_code": null,
                        "custom_model_id": null,
                        "action_on_low_score": false
                    }
                },
                {
                    "label": "createdafter Filter Usage",
                    "description": "Is 'createdafter' filter used when user query searches for items created after a specific date or time?",
                    "scoring_type": "PI_SCORER",
                    "python_code": null,
                    "custom_model_id": null,
                    "parameters": null,
                    "weight": 1.0,
                    "action_dimension": {
                        "label": "createdafter Filter Eligibility",
                        "description": "Is the use of 'createdafter' filter necessary to answer the user quey?",
                        "scoring_type": "PI_SCORER",
                        "python_code": null,
                        "custom_model_id": null,
                        "action_on_low_score": false
                    }
                },
                {
                    "label": "author Filter Usage",
                    "description": "Is 'author' filter used when user query searches for items authored by a specific person?",
                    "scoring_type": "PI_SCORER",
                    "python_code": null,
                    "custom_model_id": null,
                    "parameters": null,
                    "weight": 1.0,
                    "action_dimension": {
                        "label": "author Filter Eligibility",
                        "description": "Is the use of 'author' filter necessary to answer the user quey?",
                        "scoring_type": "PI_SCORER",
                        "python_code": null,
                        "custom_model_id": null,
                        "action_on_low_score": false
                    }
                },
                {
                    "label": "component Filter Usage",
                    "description": "Is 'component' filter used when user query searches for items belonging to a specific component?",
                    "scoring_type": "PI_SCORER",
                    "python_code": null,
                    "custom_model_id": null,
                    "parameters": null,
                    "weight": 1.0,
                    "action_dimension": {
                        "label": "component Filter Eligibility",
                        "description": "Is the use of 'component' filter necessary to answer the user quey?",
                        "scoring_type": "PI_SCORER",
                        "python_code": null,
                        "custom_model_id": null,
                        "action_on_low_score": false
                    }
                },
                {
                    "label": "status Filter Usage",
                    "description": "Is 'status' filter used when user query searches for items with a specific status?",
                    "scoring_type": "PI_SCORER",
                    "python_code": null,
                    "custom_model_id": null,
                    "parameters": null,
                    "weight": 1.0,
                    "action_dimension": {
                        "label": "status Filter Eligibility",
                        "description": "Is the use of 'status' filter necessary to answer the user quey?",
                        "scoring_type": "PI_SCORER",
                        "python_code": null,
                        "custom_model_id": null,
                        "action_on_low_score": false
                    }
                },
                {
                    "label": "statuscategory Filter Usage",
                    "description": "Is 'statuscategory' filter used when user query searches for items with status belonging to a specific category?",
                    "scoring_type": "PI_SCORER",
                    "python_code": null,
                    "custom_model_id": null,
                    "parameters": null,
                    "weight": 1.0,
                    "action_dimension": {
                        "label": "statuscategory Filter Eligibility",
                        "description": "Is the use of 'statuscategory' filter necessary to answer the user quey?",
                        "scoring_type": "PI_SCORER",
                        "python_code": null,
                        "custom_model_id": null,
                        "action_on_low_score": false
                    }
                },
                {
                    "label": "label Filter Usage",
                    "description": "Is 'label' filter used when user query searches for items with a specific label?",
                    "scoring_type": "PI_SCORER",
                    "python_code": null,
                    "custom_model_id": null,
                    "parameters": null,
                    "weight": 1.0,
                    "action_dimension": {
                        "label": "crealabeltedafter Filter Eligibility",
                        "description": "Is the use of 'label' filter necessary to answer the user quey?",
                        "scoring_type": "PI_SCORER",
                        "python_code": null,
                        "custom_model_id": null,
                        "action_on_low_score": false
                    }
                },
                {
                    "label": "assignee Filter Usage",
                    "description": "Is 'assignee' filter used when user query searches for items assigned to a specific person?",
                    "scoring_type": "PI_SCORER",
                    "python_code": null,
                    "custom_model_id": null,
                    "parameters": null,
                    "weight": 1.0,
                    "action_dimension": {
                        "label": "assignee Filter Eligibility",
                        "description": "Is the use of 'assignee' filter necessary to answer the user quey?",
                        "scoring_type": "PI_SCORER",
                        "python_code": null,
                        "custom_model_id": null,
                        "action_on_low_score": false
                    }
                },
                {
                    "label": "reporter Filter Usage",
                    "description": "Is 'reporter' filter used when user query searches for items reported by a specific person?",
                    "scoring_type": "PI_SCORER",
                    "python_code": null,
                    "custom_model_id": null,
                    "parameters": null,
                    "weight": 1.0,
                    "action_dimension": {
                        "label": "reporter Filter Eligibility",
                        "description": "Is the use of 'reporter' filter necessary to answer the user quey?",
                        "scoring_type": "PI_SCORER",
                        "python_code": null,
                        "custom_model_id": null,
                        "action_on_low_score": false
                    }
                },
                {
                    "label": "type Filter Usage",
                    "description": "Is 'type' filter used when user query searches items of a specific type?",
                    "scoring_type": "PI_SCORER",
                    "python_code": null,
                    "custom_model_id": null,
                    "parameters": null,
                    "weight": 1.0,
                    "action_dimension": {
                        "label": "type Filter Eligibility",
                        "description": "Is the use of 'type' filter necessary to answer the user quey?",
                        "scoring_type": "PI_SCORER",
                        "python_code": null,
                        "custom_model_id": null,
                        "action_on_low_score": false
                    }
                },
                {
                    "label": "from Filter Usage",
                    "description": "Is 'from' filter used when user query searches items updated by, commented on or created by the person?",
                    "scoring_type": "PI_SCORER",
                    "python_code": null,
                    "custom_model_id": null,
                    "parameters": null,
                    "weight": 1.0,
                    "action_dimension": {
                        "label": "from Filter Eligibility",
                        "description": "Is the use of 'from' filter necessary to answer the user quey?",
                        "scoring_type": "PI_SCORER",
                        "python_code": null,
                        "custom_model_id": null,
                        "action_on_low_score": false
                    }
                },
                {
                    "label": "updated Filter Usage",
                    "description": "Is 'updated' filter used when user query searches the items updated on or after the specific date?",
                    "scoring_type": "PI_SCORER",
                    "python_code": null,
                    "custom_model_id": null,
                    "parameters": null,
                    "weight": 1.0,
                    "action_dimension": {
                        "label": "updated Filter Eligibility",
                        "description": "Is the use of 'updated' filter necessary to answer the user quey?",
                        "scoring_type": "PI_SCORER",
                        "python_code": null,
                        "custom_model_id": null,
                        "action_on_low_score": false
                    }
                },
                {
                    "label": "after Filter Usage",
                    "description": "Is 'after' filter used when user query searches the items created after the specific date?",
                    "scoring_type": "PI_SCORER",
                    "python_code": null,
                    "custom_model_id": null,
                    "parameters": null,
                    "weight": 1.0,
                    "action_dimension": {
                        "label": "after Filter Eligibility",
                        "description": "Is the use of 'after' filter necessary to answer the user quey?",
                        "scoring_type": "PI_SCORER",
                        "python_code": null,
                        "custom_model_id": null,
                        "action_on_low_score": false
                    }
                },
                {
                    "label": "before Filter Usage",
                    "description": "Is 'before' filter used when user query searches the items created before the specific date?",
                    "scoring_type": "PI_SCORER",
                    "python_code": null,
                    "custom_model_id": null,
                    "parameters": null,
                    "weight": 1.0,
                    "action_dimension": {
                        "label": "before Filter Eligibility",
                        "description": "Is the use of 'before' filter necessary to answer the user quey?",
                        "scoring_type": "PI_SCORER",
                        "python_code": null,
                        "custom_model_id": null,
                        "action_on_low_score": false
                    }
                },
                {
                    "label": "app Filter Usage",
                    "description": "Is 'app' filter used when user query searches items created in specific app?",
                    "scoring_type": "PI_SCORER",
                    "python_code": null,
                    "custom_model_id": null,
                    "parameters": null,
                    "weight": 1.0,
                    "action_dimension": {
                        "label": "app Filter Eligibility",
                        "description": "Is the use of 'app' filter necessary to answer the user quey?",
                        "scoring_type": "PI_SCORER",
                        "python_code": null,
                        "custom_model_id": null,
                        "action_on_low_score": false
                    }
                },
                {
                    "label": "date Filter Usage",
                    "description": "Are 'date' filters used when the user specifies a time frame?",
                    "scoring_type": "PI_SCORER",
                    "python_code": null,
                    "custom_model_id": null,
                    "parameters": null,
                    "weight": 1.0,
                    "action_dimension": {
                        "label": "date Filter Eligibility",
                        "description": "Is the use of 'date' filter necessary to answer the user quey?",
                        "scoring_type": "PI_SCORER",
                        "python_code": null,
                        "custom_model_id": null,
                        "action_on_low_score": false
                    }
                },
                {
                    "label": "owner Filter Usage",
                    "description": "Is the 'owner' filter used when the user query searches the items created by a person?",
                    "scoring_type": "PI_SCORER",
                    "python_code": null,
                    "custom_model_id": null,
                    "parameters": null,
                    "weight": 1.0,
                    "action_dimension": {
                        "label": "owner Filter Eligibility",
                        "description": "Is the use of 'owner' filter necessary to answer the user quey?",
                        "scoring_type": "PI_SCORER",
                        "python_code": null,
                        "custom_model_id": null,
                        "action_on_low_score": false
                    }
                },
                {
                    "label": "documentcategory Filter Usage",
                    "description": "Is the 'documentcategory' filter used when the user specifies a category?",
                    "scoring_type": "PI_SCORER",
                    "python_code": null,
                    "custom_model_id": null,
                    "parameters": null,
                    "weight": 1.0,
                    "action_dimension": {
                        "label": "documentcategory Filter Eligibility",
                        "description": "Is the use of 'documentcategory' filter necessary to answer the user quey?",
                        "scoring_type": "PI_SCORER",
                        "python_code": null,
                        "custom_model_id": null,
                        "action_on_low_score": false
                    }
                },
                {
                    "label": "Multiple Filters Usage",
                    "description": "Are multiple filters used correctly when specified by the user's query?",
                    "scoring_type": "PI_SCORER",
                    "python_code": null,
                    "custom_model_id": null,
                    "parameters": null,
                    "weight": 1.0,
                    "action_dimension": {
                        "label": "multiple Filter Eligibility",
                        "description": "Is the use of multiple filters necessary to answer the user quey?",
                        "scoring_type": "PI_SCORER",
                        "python_code": null,
                        "custom_model_id": null,
                        "action_on_low_score": false
                    }
                }
            ],
            "action_dimension": {
                "label": "Direct Score Calculation Eligibility",
                "description": "Is the score directly calculatable?",
                "scoring_type": "CUSTOM_MODEL_SCORER",
                "python_code": null,
                "custom_model_id": "glean-dimension-scoring",
                "action_on_low_score": true
            }
        },
        {
            "label": "Application Behavior",
            "description": "What constraints should the response satisfy in general?",
            "weight": 1.0,
            "sub_dimensions": [
                {
                    "label": "No Direct Answers",
                    "description": "Does the response avoid directly answering the user's query?",
                    "scoring_type": "PI_SCORER",
                    "python_code": null,
                    "custom_model_id": null,
                    "parameters": null,
                    "weight": 1.0,
                    "action_dimension": null
                },
                {
                    "label": "No Filler Words",
                    "description": "Does the response not contain any other text besides the search query?",
                    "scoring_type": "PI_SCORER",
                    "python_code": null,
                    "custom_model_id": null,
                    "parameters": null,
                    "weight": 1.0,
                    "action_dimension": null
                },
                {
                    "label": "Bad Date Filters",
                    "description": "Does the response avoid using the date filters like 'createdbefore' for 'latest' or 'recent' requests without a specific time frame?",
                    "scoring_type": "PI_SCORER",
                    "python_code": null,
                    "custom_model_id": null,
                    "parameters": null,
                    "weight": 1.0,
                    "action_dimension": {
                        "label": "Timeframe Check",
                        "description": "Does the query contain words like 'latest' or 'recent' without mentioning specific time frame?",
                        "scoring_type": "PI_SCORER",
                        "python_code": null,
                        "custom_model_id": null,
                        "action_on_low_score": false
                    }
                },
                {
                    "label": "Filter Value Validity",
                    "description": "Is value type for each filter in the response is among the types we expect for that particular filter?",
                    "scoring_type": "PI_SCORER",
                    "python_code": null,
                    "custom_model_id": null,
                    "parameters": null,
                    "weight": 1.0,
                    "action_dimension": {
                        "label": "Filter Name Check",
                        "description": "Does the response contain any filters in the format 'filter_name:'?",
                        "scoring_type": "PI_SCORER",
                        "python_code": null,
                        "custom_model_id": null,
                        "action_on_low_score": false
                    }
                }
            ],
            "action_dimension": {
                "label": "Direct Score Calculation Eligibility",
                "description": "Is the score directly calculatable?",
                "scoring_type": "CUSTOM_MODEL_SCORER",
                "python_code": null,
                "custom_model_id": "glean-dimension-scoring",
                "action_on_low_score": true
            }
        }
    ]
}
